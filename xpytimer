#!/usr/bin/env python3
#
# 	$Id: xpytimer,v 1.11 2019/07/12 12:23:19 u1 Exp u1 $	

import sys
import os
import re

import subprocess
import time
import threading

from Xlib import X, display

import pygame
import pygame.gfxdraw, pygame.transform
import pygcolor

from perlcompat import die, getopts

scriptname = os.path.basename(sys.argv[0])
def usage():
    die(f'''{scriptname} usage: [OPTIONS] TIME [TIME]
    -s - TIME is second
    -c - mode for chairman
    -W WIDTH - set widht to WIDTH
    -H HEIGHT - set height to HEIGHT
    -h show this usage''')

COLOR_AT_DEFAULT = { 'foreground': 'White', 'background': 'Black' }
COLOR_AT = {
    100: { 'foreground': os.environ.get('THEME_COLOR', 'Aquamarine1') },
    20:  { 'foreground': 'DarkOrange1' },
    10:  { 'foreground': 'firebrick1' },
    0:   { 'foreground': 'Black', 'background': 'firebrick1' },
}

X_FONT_NAME = '-hiro-fixed-medium-r-normal--8-80-75-75-c-80-iso646.1991-irv'
X_FONT_WIDTH, X_FONT_HEIGHT = 8, 8

PYGAME_FONT_NAME = '/etc/alternatives/fonts-japanese-gothic.ttf'
PYGAME_FONT_SIZE = 680

class Timer:
    def __init__(self, val, is_second=False):
        self.second = val if is_second else \
                      val * 60
        self.lasttime = self.second

    def __str__(self):
        last = max(self.last(), -1 * self.last())
        minute, second = int(last / 60), int(last % 60)
        return f'{minute:02}:{second:02}'

    def last(self):
        return self.lasttime

    def reset(self):
        self.lasttime = self.second

    def ratio(self):
        return self.last() / self.second

    def is_end(self):
        return self.last() <= 0

    def advance(self):
        time.sleep(1)
        self.lasttime -= 1

class Monitor:
    def __init__(self, timer, exist_next):
        self.timer = timer
        self.run = True
        self.last_ratio = None
        self.is_blink = False
        self.exist_next = exist_next

    def usage(self):
        return '\'q\': quit, otherwise: pause/resume'

    # ------------------------
    # events
    def event_loop(self):
        kh = threading.Thread(target=self.keyboard_handler)
        kh.start()
      
        while True:
            if not self.run:
                time.sleep(1)
                continue
            # if time is up and next timer exists, end
            if self.timer.is_end() and self.exist_next:
                break
            if self.last_ratio != self.ratio_at():
                self.change_ratio_at_hook()
            self.last_ratio = self.ratio_at()
            if self.ratio_at() == min(COLOR_AT.keys()):
                self.is_blink = not(self.is_blink)
            self.draw()
            self.timer.advance()

    def ratio_at(self):
        for ratio  in sorted(COLOR_AT):
            if ratio >= round(self.timer.ratio() * 100):
                return ratio

    def keyboard_handler(self):
        while True:
            if input(self.usage() + ': ') == 'q':
                os._exit(0)
            else:
                if self.run:
                    print('** PAUSE **')
                self.run = not(self.run)                

    def change_ratio_at_hook(self):
        None

    # ------------------------
    # draw/color
    def _color(self, elem):
        color_ref = COLOR_AT[self.ratio_at()]
        return color_ref.get(elem, COLOR_AT_DEFAULT[elem])

    def fg_color(self):      
        return self._color('background') if self.is_blink \
            else self._color('foreground')

    def bg_color(self):
        return self._color('foreground') if self.is_blink \
            else self._color('background')

def get_screen_size():
    global opts
    output = subprocess.getoutput('xrandr --current')
    m = re.search(r'(?:DP-?\d|HDMI-?\d) connected\s*(?:primary)?\s*(\d+)x(\d+)',
                  '\n'.join(reversed(output.split('\n'))))
    if m:
        width = int(m.group(1)) if not opts.W else int(opts.W)
        height = int(m.group(2)) if not opts.H else int(opts.H)
        return width, height

class Mon_X(Monitor):
    def __init__(self, *args):
        super().__init__(*args)

        # 1. connect to X server
        self.disp = display.Display()
        self.screen = self.disp.screen()
        self.colormap = self.screen.default_colormap
         
        # 2. create window
        self.max_width, self.max_height = get_screen_size()

        self.y = self.max_height - X_FONT_HEIGHT
        self.width = self.max_width
         
        self.window = self.screen.root.create_window(
            # x, y, width, height
            0, self.y, self.width, X_FONT_HEIGHT,
            # border_width
            0,
            # depth
            self.screen.root_depth,
            # class
            X.InputOutput,
            X.CopyFromParent,
            background_pixel=self.screen.black_pixel,
            override_redirect=1,
            colormap=X.CopyFromParent,
            # 3. use XSelectInput() to get necessary events
            # events list; ref: http://rio.la.coocan.jp/lab/xlib/004event.htm
            event_mask = (X.ExposureMask))
        self.window.set_wm_name(scriptname)
        self.font = self.disp.open_font(X_FONT_NAME)
        self.gcs = self._create_gcs()         
        # 4. show window
        self.window.map()

        os.system('pidof xcompmgr > /dev/null && transset --id {} .7 > /dev/null'
                  .format(self.window.id))

    def _create_gcs(self):
        gcs = {}

        colors = list(COLOR_AT_DEFAULT.values())
        for _ in COLOR_AT.values():
            colors += list(_.values())

        for color in colors:
            pixel = self.colormap.alloc_named_color(color).pixel
            gcs[color] = {}
            gcs[color]['line'] = self.window.create_gc(foreground=pixel)
            gcs[color]['font'] = self.window.create_gc(font=self.font, foreground=pixel)
        return gcs

    # ------------------------
    # draw/color
    def draw(self):
        color = self.fg_color()
        self.window.clear_area(0, 0, self.width, X_FONT_HEIGHT)
        # draw line
        self.window.fill_rectangle(self.gcs[color]['line'], len(str(self.timer)) * X_FONT_WIDTH, 0,
                                   max(0, int(self.max_width * self.timer.ratio())), X_FONT_HEIGHT)
        # draw font background
        string  = str(self.timer)
        self.window.fill_rectangle(self.gcs[self.bg_color()]['line'], 0, 0,
                                   X_FONT_WIDTH * len(string), X_FONT_HEIGHT)
        # draw font
        self.window.poly_text(self.gcs[color]['font'], 0, X_FONT_HEIGHT - 1,
                              [ chr(c).encode() for c in list(string.encode()) ])
        self.window.configure(stack_mode=X.Above)
        # NOTE: the following line is necessary due to unknown reason
        self.colormap.alloc_named_color('white')

class Mon_pygame(Monitor):
    def __init__(self, *args):
        super().__init__(*args)
        self.init_display(*get_screen_size())
        self.palette = pygcolor.Null()

    def init_display(self, width, height):          
        # initialize pygame and create a window
        pygame.display.init()
        pygame.font.init()
        self.screen = pygame.display.set_mode((width, height))        
        self.font = pygame.font.Font(PYGAME_FONT_NAME, PYGAME_FONT_SIZE)
        self.small_font = pygame.font.Font(PYGAME_FONT_NAME, int(PYGAME_FONT_SIZE/8))

    def usage(self):
        return '[SPACE]: pause/resume, q: quit, r: reset timer'

    # ------------------------
    # events
    def keyboard_handler(self):
        def pause():
            self._draw()
            self.draw_label('** PAUSE **', self.small_font, .5, .1)
            self.update()
            self.run = False

        while True:
            for event in pygame.event.get():
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        if self.run:
                            pause()
                        else:
                            self.run = True
                    elif event.key == pygame.K_q:
                        os._exit(0)
                    elif event.key == pygame.K_r:
                        self.timer.reset()
                        pause()

    # ------------------------
    # draw/color
    def update(self):
        pygame.display.update()
        self.screen.fill((0, 0, 0, 255))

    def _draw(self):
        # draw font background
        pygame.draw.rect(self.screen, self.palette.rgba(self.bg_color()),
                         (0, 0, self.screen.get_width(), self.screen.get_height()))
        self.draw_label(str(self.timer), self.font, .5, .5)
        self.draw_label(self.usage(), self.small_font, .5, .9)

    def draw(self):
        self._draw()
        self.update()

    def draw_label(self, label, font, x, y):
        color = self.palette.rgba(self.fg_color())
        text = font.render(label, 1, color)
        x *= self.screen.get_width() - text.get_width()
        y *= self.screen.get_height() - text.get_height()
        self.screen.blit(text, (x, y))

    def change_ratio_at_hook(self):
        None
        # ring bell? -u1 [2019/07/12]

def main():
    global opts
    opts = getopts('scW:H:h') or usage()
    if opts.h:
        usage()

    monitor = Mon_pygame if opts.c else Mon_X
    for arg in sys.argv[1:]:
        w = monitor(Timer(float(arg), opts.s), not(arg == sys.argv[-1]))
        w.event_loop()

if __name__ == "__main__":
    main()
