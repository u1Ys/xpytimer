#!/usr/bin/env python3

import sys
import os
import re

import subprocess
import time
import threading

from Xlib import X, display

import pygame
import pygame.gfxdraw, pygame.transform
import pygcolor

from perlcompat import die, getopts

COLOR_AT_DEFAULT = { 'foreground': 'White', 'background': 'Black' }
COLOR_AT = {
    100: { 'foreground': os.environ.get('THEME_COLOR', 'Aquamarine1') },
    20:  { 'foreground': 'DarkOrange1' },
    10:  { 'foreground': 'firebrick1' },
    0:   { 'foreground': 'Black', 'background': 'firebrick1' },
}

X_FONT_NAME = '-hiro-fixed-medium-r-normal--8-80-75-75-c-80-iso646.1991-irv'
X_FONT_WIDTH, X_FONT_HEIGHT = 8, 8

PYGAME_FONT_NAME = '/etc/alternatives/fonts-japanese-gothic.ttf'
PYGAME_FONT_SIZE = 680

SOUND_CMD = 'aplay ~/lib/xpytimer/bell.wav 2> /dev/null'


prog = os.path.basename(sys.argv[0])
def usage():
    die(f'''{prog} usage: [OPTIONS] TIME [TIME]
    -s - TIME is second
    -R NUMBER - repeat timer NUMBER time
    -W WIDTH - set widht to WIDTH
    -H HEIGHT - set height to HEIGHT
    -m cli|x|pygame - specify type of monitor
    -S - ring sound. If you want to ring bell, put your preferable wav
     file on ‘~/lib/xpytimer/bell.wav’
    -h show this usage''')


class Timer:
    def __init__(self, val, is_second=False):
        self.second = val if is_second \
            else val * 60
        self.lasttime = self.second

    def __str__(self):
        last = max(self.last(), -1 * self.last())
        minute, second = int(last / 60), int(last % 60)
        return f'{minute:02}:{second:02}'

    def last(self):
        return self.lasttime

    def reset(self):
        self.lasttime = self.second

    def ratio(self):
        return self.last() / self.second

    def is_end(self):
        return self.last() <= 0

    def advance(self):
        time.sleep(1)
        self.lasttime -= 1


class Monitor:
    def __init__(self, timer, exist_next=False, sound=False):
        self.timer = timer
        self.exist_next = exist_next
        self.sound = sound

        self.run = True
        self.last_ratio = None
        self.is_blink = False

    def _usage(self):
        return "'q': quit, otherwise: pause/resume"

    # events
    def event_loop(self):
        kh = threading.Thread(target=self.keyboard_handler)
        kh.start()
        while True:
            if not self.run:
                time.sleep(1)
                continue
            # if time is up and next timer exists, end
            if self.timer.is_end() and self.exist_next:
                break
            if self.last_ratio != self._ratio_at():
                self.change_ratio_hook()
            self.last_ratio = self._ratio_at()
            if self._ratio_at() == min(COLOR_AT.keys()):
                self.is_blink = not(self.is_blink)
            self.draw()
            self.timer.advance()

    def draw(self):
        NotImplemented

    def _ratio_at(self):
        for ratio  in sorted(COLOR_AT):
            if ratio >= round(self.timer.ratio() * 100):
                return ratio

    def keyboard_handler(self):
        while True:
            if input(self._usage() + ': ') == 'q':
                os._exit(0)
            else:
                if self.run:
                    print('** PAUSE **')
                self.run = not(self.run)

    def change_ratio_hook(self):
        if self.sound:
            os.system(SOUND_CMD + ' &')

    # draw/color
    def _color(self, elem):
        color_ref = COLOR_AT[self._ratio_at()]
        return color_ref.get(elem, COLOR_AT_DEFAULT[elem])

    def fg_color(self):      
        return self._color('background') if self.is_blink \
            else self._color('foreground')

    def bg_color(self):
        return self._color('foreground') if self.is_blink \
            else self._color('background')

class Mon_CLI(Monitor):
    def draw(self):
        print(str(self.timer))

    def _usage(self):
        return super()._usage() + '\n'

def get_screen_size():
    global opts
    output = subprocess.getoutput('xrandr --current')
    m = re.search(r'(?:DP-?\d|HDMI-?\d) connected\s*(?:primary)?\s*(\d+)x(\d+)',
                  '\n'.join(reversed(output.split('\n'))))
    if m:
        width = int(m.group(1)) if not opts.W else int(opts.W)
        height = int(m.group(2)) if not opts.H else int(opts.H)
        return width, height


class Mon_X(Monitor):
    def __init__(self, *args, **kargs):
        super().__init__(*args, **kargs)

        # 1. connect to X server
        self.disp = display.Display()
        self.screen = self.disp.screen()
        self.colormap = self.screen.default_colormap
         
        # 2. create window
        self.max_width, self.max_height = get_screen_size()

        self.y = self.max_height - X_FONT_HEIGHT
        self.width = self.max_width
         
        self.window = self.screen.root.create_window(
            # x, y, width, height
            0, self.y, self.width, X_FONT_HEIGHT,
            # border_width
            0,
            # depth
            self.screen.root_depth,
            # class
            X.InputOutput,
            X.CopyFromParent,
            background_pixel=self.screen.black_pixel,
            override_redirect=1,
            colormap=X.CopyFromParent,
            # 3. use XSelectInput() to get necessary events
            # events list; ref: http://rio.la.coocan.jp/lab/xlib/004event.htm
            event_mask = (X.ExposureMask))
        self.window.set_wm_name(prog)
        self.font = self.disp.open_font(X_FONT_NAME)
        self.gcs = self._create_gcs()         
        # 4. show window
        self.window.map()

        os.system('pidof xcompmgr > /dev/null && transset --id {} .7 > /dev/null'
                  .format(self.window.id))

    def _create_gcs(self):
        gcs = {}

        colors = list(COLOR_AT_DEFAULT.values())
        for _ in COLOR_AT.values():
            colors += list(_.values())

        for color in colors:
            pixel = self.colormap.alloc_named_color(color).pixel
            gcs[color] = {}
            gcs[color]['line'] = self.window.create_gc(foreground=pixel)
            gcs[color]['font'] = self.window.create_gc(font=self.font, foreground=pixel)
        return gcs

    # ------------------------
    # draw/color
    def draw(self):
        color = self.fg_color()
        self.window.clear_area(0, 0, self.width, X_FONT_HEIGHT)
        # draw line
        self.window.fill_rectangle(self.gcs[color]['line'], len(str(self.timer)) * X_FONT_WIDTH, 0,
                                   max(0, int(self.max_width * self.timer.ratio())), X_FONT_HEIGHT)
        # draw font background
        string  = str(self.timer)
        self.window.fill_rectangle(self.gcs[self.bg_color()]['line'], 0, 0,
                                   X_FONT_WIDTH * len(string), X_FONT_HEIGHT)
        # draw font
        self.window.poly_text(self.gcs[color]['font'], 0, X_FONT_HEIGHT - 1,
                              [ chr(c).encode() for c in list(string.encode()) ])
        self.window.configure(stack_mode=X.Above)
        # NOTE: the following line is necessary due to unknown reason
        self.colormap.alloc_named_color('white')


class ChairMan(Monitor):
    def __init__(self, *args, **kargs):
        super().__init__(*args, **kargs)
        self.init_display(*get_screen_size())
        self.palette = pygcolor.Null()

    def init_display(self, width, height):          
        # initialize pygame and create a window
        pygame.display.init()
        pygame.font.init()
        self.screen = pygame.display.set_mode((width, height))        
        self.font = pygame.font.Font(PYGAME_FONT_NAME, PYGAME_FONT_SIZE)
        self.small_font = pygame.font.Font(PYGAME_FONT_NAME, int(PYGAME_FONT_SIZE/8))

    def _usage(self):
        return '[SPACE]: pause/resume, q: quit, r: reset timer'

    # events
    def keyboard_handler(self):
        def pause():
            self._draw()
            self.draw_label('** PAUSE **', self.small_font, .5, .1)
            self.update()
            self.run = False

        while True:
            for event in pygame.event.get():
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        if self.run:
                            pause()
                        else:
                            self.run = True
                    elif event.key == pygame.K_q:
                        os._exit(0)
                    elif event.key == pygame.K_r:
                        self.timer.reset()
                        pause()

    # draw/color
    def update(self):
        pygame.display.update()
        self.screen.fill((0, 0, 0, 255))

    def _draw(self):
        # draw font background
        pygame.draw.rect(self.screen, self.palette.rgba(self.bg_color()),
                         (0, 0, self.screen.get_width(), self.screen.get_height()))
        self.draw_label(str(self.timer), self.font, .5, .5)
        self.draw_label(self._usage(), self.small_font, .5, .9)

    def draw(self):
        self._draw()
        self.update()

    def draw_label(self, label, font, x, y):
        color = self.palette.rgba(self.fg_color())
        text = font.render(label, 1, color)
        x *= self.screen.get_width() - text.get_width()
        y *= self.screen.get_height() - text.get_height()
        self.screen.blit(text, (x, y))

monitors = {
    'cli': Mon_CLI,
    'x': Mon_X,
    'pygame': Mon_pygame,
}


if __name__ == "__main__":
    global opts
    opts = getopts('R:sm:W:H:hS') or usage()
    if opts.h:
        usage()

    times = sys.argv[1:]
    if opts.R:
        times = times * int(opts.R)
    monitor = monitors[opts.m] if opts.m else Mon_X
    for i, arg in enumerate(times):
        w = monitor(Timer(float(arg), opts.s),
                    exist_next=(i != (len(times) - 1)),
                    sound=opts.S)
        w.event_loop()
